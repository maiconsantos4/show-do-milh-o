<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Show do Milh√£o de Embriologia</title>
    <!-- Inclui Tailwind CSS para estiliza√ß√£o r√°pida e responsiva -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fonte Inter do Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};


        let app;
        let db;
        let auth;
        let userId;

        window.firebaseInitialized = false; // Flag to indicate Firebase initialization status

        async function initializeFirebaseAndAuth() {
            try {
                console.log("Firebase: Tentando inicializar...");
                console.log("Firebase Config:", firebaseConfig);
                console.log("App ID:", appId);

                if (Object.keys(firebaseConfig).length === 0 || !firebaseConfig.apiKey) {
                    console.error("Firebase: Configura√ß√£o est√° vazia ou faltando a chave da API. O Firestore N√ÉO ESTAR√Å DISPON√çVEL.");
                    // In this error case, Firebase won't be fully initialized for Firestore operations.
                    // We still call onFirebaseReady to allow the game to proceed without score saving.
                    window.firebaseInitialized = false; // Explicitly false if config is bad
                    if (window.onFirebaseReady) {
                        window.onFirebaseReady();
                    }
                    return;
                }

                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Use a promise to ensure onAuthStateChanged has fired at least once
                await new Promise(resolve => {
                    const unsubscribe = onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                            console.log("Firebase: Utilizador autenticado:", userId);
                        } else {
                            // Attempt anonymous sign-in if not already signed in
                            try {
                                if (!auth.currentUser) { // Only sign in anonymously if no user is present
                                    if (initialAuthToken) {
                                        await signInWithCustomToken(auth, initialAuthToken);
                                    } else {
                                        await signInAnonymously(auth);
                                    }
                                    userId = auth.currentUser?.uid || crypto.randomUUID(); // Get UID after sign-in
                                    console.log("Firebase: Utilizador an√≥nimo ou autenticado via token:", userId);
                                } else {
                                    userId = auth.currentUser.uid; // Already authenticated
                                    console.log("Firebase: Utilizador j√° autenticado:", userId);
                                }
                            } catch (anonError) {
                                console.error("Firebase: Erro ao tentar login an√≥nimo/token:", anonError);
                                userId = crypto.randomUUID(); // Fallback to random UUID if anonymous sign-in fails
                                console.log("Firebase: Falha na autentica√ß√£o. A usar UUID aleat√≥rio:", userId);
                            }
                        }
                        window.firebaseInitialized = true; // Set true only after userId is determined
                        if (window.onFirebaseReady) {
                            window.onFirebaseReady();
                        }
                        unsubscribe(); // Unsubscribe after the first state change
                        resolve(); // Resolve the promise
                    });
                });

            } catch (error) {
                console.error("Firebase: Erro cr√≠tico ao inicializar ou autenticar:", error);
                window.firebaseInitialized = false; // Critical failure, Firebase not ready
                if (window.onFirebaseReady) {
                    window.onFirebaseReady();
                }
            }
        }

        initializeFirebaseAndAuth();

        // Expose Firebase objects globally for use in the main script
        window.getFirestore = getFirestore;
        window.collection = collection;
        window.addDoc = addDoc;
        window.query = query;
        window.orderBy = orderBy;
        window.limit = limit;
        window.getDocs = getDocs;
        window.onSnapshot = onSnapshot;
        window.doc = doc;
        window.setDoc = setDoc;
        window.auth = auth; // Expose auth object
        window.getAuth = getAuth; // Expose getAuth function
        window.signInWithCustomToken = signInWithCustomToken;
        window.signInAnonymously = signInAnonymously;
        window.appId = appId; // Expose appId
        window.getUserId = () => userId; // Function to get current userId
    </script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%); /* Fundo com gradiente */
            color: #e2e8f0; /* Texto claro */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            overflow: hidden; /* Para evitar scroll com confetes */
        }
        .game-container {
            background-color: #2d3748; /* Fundo do container */
            border-radius: 1.5rem; /* Cantos arredondados */
            padding: 2.5rem;
            box-shadow: 0 15px 25px -5px rgba(0, 0, 0, 0.3), 0 8px 10px -6px rgba(0, 0, 0, 0.2); /* Sombra mais intensa */
            max-width: 800px;
            width: 100%;
            text-align: center;
            border: 2px solid #4a5568; /* Borda sutil */
            position: relative; /* Para o modal e confetes */
            z-index: 1; /* Garante que esteja acima dos confetes */
        }
        .question-text {
            min-height: 80px; /* Garante espa√ßo para a pergunta */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .option-button {
            background: linear-gradient(180deg, #4299e1 0%, #3182ce 100%); /* Gradiente azul */
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out; /* Transi√ß√£o mais suave */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
            cursor: pointer;
            width: 100%; /* Ocupa toda a largura dispon√≠vel */
            text-align: left; /* Alinha o texto √† esquerda */
            position: relative;
            overflow: hidden;
        }
        .option-button:hover:not(:disabled) {
            background: linear-gradient(180deg, #3182ce 0%, #2b6cb0 100%); /* Gradiente azul mais escuro no hover */
            transform: translateY(-3px); /* Efeito de levantar */
            box-shadow: 0 6px 10px -2px rgba(0, 0, 0, 0.2), 0 3px 5px -1px rgba(0, 0, 0, 0.1);
        }
        .option-button:active:not(:disabled) {
            transform: translateY(0); /* Volta ao normal no clique */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .option-button.correct {
            background: linear-gradient(180deg, #48bb78 0%, #38a169 100%); /* Gradiente verde */
            animation: pulse-correct 0.5s ease-out;
        }
        .option-button.incorrect {
            background: linear-gradient(180deg, #e53e3e 0%, #c53030 100%); /* Gradiente vermelho */
            animation: shake-incorrect 0.5s ease-out;
        }
        .option-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #4a5568; /* Cinza para desabilitado */
        }

        .start-button, .restart-button, .lifeline-button, .home-button, .difficulty-button, .audio-button {
            background: linear-gradient(180deg, #ecc94b 0%, #d69e2e 100%); /* Gradiente amarelo */
            color: #2d3748; /* Texto escuro */
            padding: 1rem 2rem;
            border-radius: 0.75rem;
            font-weight: 800; /* Mais negrito */
            font-size: 1.25rem;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
            cursor: pointer;
            text-transform: uppercase; /* Texto em mai√∫sculas */
            letter-spacing: 0.05em; /* Espa√ßamento entre letras */
        }
        .start-button:hover, .restart-button:hover, .lifeline-button:hover:not(:disabled), .home-button:hover, .difficulty-button:hover, .audio-button:hover {
            background: linear-gradient(180deg, #d69e2e 0%, #b7791f 100%); /* Amarelo mais escuro no hover */
            transform: translateY(-3px);
            box-shadow: 0 6px 10px -2px rgba(0, 0, 0, 0.2), 0 3px 5px -1px rgba(0, 0, 0, 0.1);
        }
        .lifeline-button:disabled, .difficulty-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #718096; /* Cinza para desabilitado */
            box-shadow: none;
            transform: none;
        }
        .difficulty-button.selected {
            background: linear-gradient(180deg, #48bb78 0%, #38a169 100%); /* Verde para selecionado */
            color: white;
        }
        .audio-button {
            padding: 0.75rem 1.25rem;
            font-size: 1rem;
            margin: 0 0.5rem;
        }

        /* Estilo para o modal de fim de jogo e placar */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85); /* Fundo mais escuro */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px); /* Efeito de desfoque */
            animation: fadeIn 0.3s ease-out;
        }
        .modal-content {
            background-color: #2d3748;
            padding: 3rem; /* Mais padding */
            border-radius: 1.5rem;
            text-align: center;
            box-shadow: 0 20px 30px -10px rgba(0, 0, 0, 0.5), 0 10px 15px -8px rgba(0, 0, 0, 0.3);
            max-width: 550px;
            width: 90%;
            border: 2px solid #4a5568;
            animation: scaleIn 0.3s ease-out;
        }

        /* Timer Styles */
        #timerDisplay {
            font-size: 3rem;
            font-weight: 800;
            color: #f6e05e; /* Amarelo vibrante */
            margin-bottom: 1.5rem;
            text-shadow: 0 0 10px rgba(246, 224, 94, 0.5);
            position: relative;
            height: 40px; /* Altura da barra de progresso */
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border-radius: 0.5rem;
            background-color: #4a5568; /* Cor de fundo da barra */
        }
        #timerProgressBar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%; /* Come√ßa cheio */
            background-color: #48bb78; /* Verde para progresso */
            transform-origin: left;
            transition: width 1s linear; /* Transi√ß√£o suave */
        }
        #timerDisplay.warning #timerProgressBar {
            background-color: #e53e3e; /* Vermelho para aviso */
        }
        #timerText {
            position: relative;
            z-index: 2; /* Acima da barra de progresso */
            color: white;
            font-size: 2rem; /* Ajusta o tamanho do texto do timer */
            font-weight: 800;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
        }

        /* Confetti Animation */
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #f0f; /* Cor padr√£o */
            opacity: 0;
            animation: fall 3s forwards;
            border-radius: 50%;
            pointer-events: none; /* N√£o interfere com cliques */
            z-index: 999;
        }

        @keyframes fall {
            0% { transform: translateY(-100px) rotateZ(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotateZ(720deg); opacity: 0; }
        }

        /* Keyframe Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes scaleIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        @keyframes pulse-correct {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        @keyframes shake-incorrect {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        @keyframes pulse-warning {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* New animation for prize pulse */
        @keyframes prize-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); color: #68d391; } /* Slightly larger and brighter green */
            100% { transform: scale(1); }
        }
        .prize-pulse {
            animation: prize-pulse 0.5s ease-out;
        }

        /* Placar de Pontos */
        .high-scores-list {
            list-style: none;
            padding: 0;
            margin-top: 1.5rem;
        }
        .high-scores-list li {
            background-color: #4a5568;
            padding: 0.75rem 1.5rem;
            margin-bottom: 0.5rem;
            border-radius: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.1rem;
            font-weight: 600;
        }
        .high-scores-list li:nth-child(1) { background-color: #f6e05e; color: #2d3748; } /* Ouro */
        .high-scores-list li:nth-child(2) { background-color: #a0aec0; color: #2d3748; } /* Prata */
        .high-scores-list li:nth-child(3) { background-color: #c084fc; color: #2d3748; } /* Bronze */

        /* Input de Nickname */
        .nickname-input {
            background-color: #4a5568;
            border: 1px solid #6b7280;
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            color: #e2e8f0;
            width: 100%;
            max-width: 250px;
            text-align: center;
            margin-top: 1rem;
        }
        .nickname-input:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #f6e05e;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="welcomeScreen" class="game-container">
        <h1 class="text-4xl font-extrabold mb-6 text-yellow-400">Bem-vindo ao Show do Milh√£o de Embriologia!</h1>
        <p class="text-xl mb-8 text-gray-300">Teste seus conhecimentos e tente chegar ao milh√£o!</p>

        <div class="mb-6">
            <h3 class="text-2xl font-bold mb-4">Escolha a Dificuldade:</h3>
            <div class="flex justify-center gap-4">
                <button id="difficultyEasy" class="difficulty-button selected" data-difficulty="easy">F√°cil</button>
                <button id="difficultyMedium" class="difficulty-button" data-difficulty="medium">M√©dio</button>
                <button id="difficultyHard" class="difficulty-button" data-difficulty="hard">Dif√≠cil</button>
            </div>
        </div>

        <button id="startButton" class="start-button mb-4">Come√ßar Jogo</button>
        <button id="showScoresButton" class="home-button">Ver Placar de Pontos</button>
    </div>

    <div id="gameContainer" class="game-container hidden">
        <h1 class="text-4xl font-extrabold mb-6 text-yellow-400">Show do Milh√£o de Embriologia</h1>
        <p id="questionCounter" class="text-lg text-gray-400 mb-4"></p>

        <!-- Bot√µes de √°udio removidos -->

        <div class="mb-8 p-4 bg-gray-700 rounded-xl shadow-inner">
            <p class="text-xl font-semibold text-gray-300">Pr√™mio Atual:</p>
            <p id="currentPrize" class="text-5xl font-extrabold text-green-400 mt-2">R$ 0</p>
        </div>

        <div id="timerDisplay" class="mb-6">
            <div id="timerProgressBar"></div>
            <span id="timerText">30</span>
        </div>

        <div class="flex flex-wrap justify-center gap-4 mb-8">
            <button id="lifeline5050" class="lifeline-button text-base px-6 py-3">50/50</button>
            <button id="lifelineSkip" class="lifeline-button text-base px-6 py-3">Pular Pergunta</button>
            <button id="lifelineAudience" class="lifeline-button text-base px-6 py-3">Universit√°rios</button>
            <button id="lifelineExpert" class="lifeline-button text-base px-6 py-3">‚ú® Perguntar ao Especialista</button>
        </div>

        <div id="questionArea" class="mb-8">
            <p id="questionText" class="text-2xl font-semibold mb-6 question-text"></p>
            <div id="optionsContainer" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                </div>
        </div>

        <p id="message" class="text-xl font-medium mb-6 min-h-[30px]"></p>

        <button id="nextQuestionButton" class="start-button hidden">Pr√≥xima Pergunta</button>
    </div>

    <div id="gameOverModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 id="modalTitle" class="text-3xl font-bold mb-4 text-yellow-400"></h2>
            <p id="modalMessage" class="text-xl mb-6 text-gray-300"></p>
            <div id="nicknameInputContainer" class="hidden">
                <input type="text" id="nicknameInput" class="nickname-input" placeholder="Seu Nickname" maxlength="15">
                <button id="saveScoreButton" class="start-button mt-4">Salvar Pontua√ß√£o</button>
            </div>
            <button id="modalRestartButton" class="restart-button mt-4">Jogar Novamente</button>
            <button id="modalHomeButton" class="home-button mt-4">Voltar ao In√≠cio</button>
        </div>
    </div>

    <div id="highScoresModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 class="text-3xl font-bold mb-4 text-yellow-400">Placar de Pontos</h2>
            <div id="loadingScores" class="text-gray-400 mb-4">Carregando placar...</div>
            <ul id="highScoresList" class="high-scores-list">
                </ul>
            <button id="closeScoresButton" class="home-button mt-6">Fechar</button>
        </div>
    </div>

    <script type="module">
        // Array de objetos de perguntas, cada um com a pergunta, op√ß√µes, √≠ndice da resposta correta, pr√™mio e explica√ß√£o.
        const questions = [
            {
                question: "Qual √© o nome da primeira c√©lula formada ap√≥s a fertiliza√ß√£o de um √≥vulo por um espermatozoide?",
                options: ["A) G√¢meta", "B) Zigoto", "C) Blastocisto", "D) M√≥rula"],
                correctAnswerIndex: 1,
                prize: 1000,
                explanation: "O **zigoto** √© a c√©lula diploide formada pela fus√£o de um √≥vulo e um espermatozoide, marcando o in√≠cio do desenvolvimento embrion√°rio."
            },
            {
                question: "Em que fase do desenvolvimento embrion√°rio ocorre a implanta√ß√£o no √∫tero?",
                options: ["A) M√≥rula", "B) G√°strula", "C) Blastocisto", "D) N√™urula"],
                correctAnswerIndex: 2,
                prize: 5000,
                explanation: "A implanta√ß√£o ocorre na fase de **blastocisto**, quando o embri√£o, j√° com uma cavidade interna e camadas celulares diferenciadas, se adere √† parede uterina."
            },
            {
                question: "Quais s√£o as tr√™s camadas germinativas prim√°rias formadas durante a gastrula√ß√£o?",
                options: ["A) Ectoderme, Mesoderme, Endoderme", "B) Epiblasto, Hipoblasto, Mesoderma", "C) Trofoblasto, Embrioblasto, Saco Vitelino", "D) √Çmnio, C√≥rio, Alantoide"],
                correctAnswerIndex: 0,
                prize: 10000,
                explanation: "Durante a gastrula√ß√£o, o embri√£o forma tr√™s camadas germinativas: a **ectoderme** (externa), a **mesoderme** (m√©dia) e a **endoderme** (interna), que dar√£o origem a todos os tecidos e √≥rg√£os."
            },
            {
                question: "A partir de qual camada germinativa se desenvolvem o sistema nervoso e a epiderme?",
                options: ["A) Mesoderme", "B) Endoderme", "C) Ectoderme", "D) Notocorda"],
                correctAnswerIndex: 2,
                prize: 50000,
                explanation: "A **ectoderme** √© a camada mais externa e d√° origem a estruturas como o sistema nervoso central e perif√©rico, a epiderme e seus anexos (cabelo, unhas), e o esmalte dent√°rio."
            },
            {
                question: "O que √© a notocorda e qual sua fun√ß√£o principal no desenvolvimento embrion√°rio?",
                options: ["A) Uma estrutura que forma o cora√ß√£o.", "B) Um precursor da medula espinhal e indutor da forma√ß√£o do tubo neural.", "C) A camada externa da pele.", "D) Uma estrutura que se torna o intestino."],
                correctAnswerIndex: 1,
                prize: 100000,
                explanation: "A **notocorda** √© uma estrutura mesod√©rmica que serve como eixo prim√°rio do embri√£o, induzindo a forma√ß√£o do tubo neural (precursor do sistema nervoso central) e contribuindo para o desenvolvimento da coluna vertebral."
            },
            {
                question: "Qual √© o processo de forma√ß√£o dos √≥rg√£os a partir das tr√™s camadas germinativas?",
                options: ["A) Gastrula√ß√£o", "B) Neurula√ß√£o", "C) Organog√™nese", "D) Clivagem"],
                correctAnswerIndex: 2,
                prize: 500000,
                explanation: "A **organog√™nese** √© o processo de forma√ß√£o e desenvolvimento dos √≥rg√£os a partir das tr√™s camadas germinativas (ectoderme, mesoderme e endoderme) durante o per√≠odo embrion√°rio."
            },
            {
                question: "A forma√ß√£o dos somitos, blocos de mesoderme paraxial que d√£o origem a v√©rtebras, m√∫sculos e derme, √© caracter√≠stica de qual per√≠odo do desenvolvimento embrion√°rio?",
                options: ["A) Per√≠odo pr√©-embrion√°rio", "B) Per√≠odo embrion√°rio", "C) Per√≠odo fetal", "D) Per√≠odo de clivagem"],
                correctAnswerIndex: 1,
                prize: 1000000,
                explanation: "Os **somitos** se formam durante o **per√≠odo embrion√°rio**, que vai da 3¬™ √† 8¬™ semana de gesta√ß√£o, sendo crucial para a forma√ß√£o das estruturas segmentadas do corpo."
            },
            {
                question: "Qual estrutura embrion√°ria √© respons√°vel pela troca de nutrientes e res√≠duos entre a m√£e e o feto?",
                options: ["A) Saco vitelino", "B) √Çmnio", "C) Alantoide", "D) Placenta"],
                correctAnswerIndex: 3,
                prize: 2000000,
                explanation: "A **placenta** √© um √≥rg√£o tempor√°rio que se forma durante a gravidez, essencial para a troca de oxig√™nio, nutrientes e res√≠duos entre a m√£e e o feto, al√©m de produzir horm√¥nios importantes."
            },
            {
                question: "O que √© clivagem no desenvolvimento embrion√°rio?",
                options: ["A) A forma√ß√£o das camadas germinativas.", "B) Divis√µes mit√≥ticas r√°pidas do zigoto sem crescimento celular.", "C) A implanta√ß√£o do blastocisto no √∫tero.", "D) O processo de forma√ß√£o do tubo neural."],
                correctAnswerIndex: 1,
                prize: 5000000,
                explanation: "A **clivagem** √© uma s√©rie de divis√µes mit√≥ticas r√°pidas do zigoto que aumentam o n√∫mero de c√©lulas (blast√¥meros) sem um aumento significativo no tamanho total do embri√£o."
            },
            {
                question: "A partir de qual camada germinativa se desenvolvem os m√∫sculos, ossos e o sistema circulat√≥rio?",
                options: ["A) Ectoderme", "B) Endoderme", "C) Mesoderme", "D) Notocorda"],
                correctAnswerIndex: 2,
                prize: 10000000,
                explanation: "A **mesoderme** √© a camada germinativa m√©dia que d√° origem a uma vasta gama de tecidos e √≥rg√£os, incluindo m√∫sculos, ossos, cartilagens, sistema circulat√≥rio, rins e g√¥nadas."
            }
        ];

        // Vari√°veis de estado do jogo
        let shuffledQuestions = [];
        let currentQuestionIndex = 0;
        let currentPrize = 0;
        let gameStarted = false;
        let canAnswer = true; // Controla se o usu√°rio pode clicar nas op√ß√µes
        let lifeline5050Used = false;
        let lifelineSkipUsed = false;
        let lifelineAudienceUsed = false;
        let lifelineExpertUsed = false; // New lifeline state
        let timer;
        let timeLeft = 30; // Tempo em segundos por pergunta
        let TIME_LIMIT = 30; // Constante para o tempo limite, ajustada pela dificuldade
        const EXPLANATION_DELAY = 4000; // Tempo em milissegundos para exibir a explica√ß√£o antes de avan√ßar

        // Vari√°veis de √°udio removidas

        // Refer√™ncias aos elementos do DOM
        const welcomeScreen = document.getElementById('welcomeScreen');
        const gameContainer = document.getElementById('gameContainer');
        const startButton = document.getElementById('startButton');
        const showScoresButton = document.getElementById('showScoresButton');
        const difficultyButtons = document.querySelectorAll('.difficulty-button');
        // Bot√µes de √°udio removidos do DOM no HTML, ent√£o n√£o precisamos de refer√™ncias aqui.

        const questionText = document.getElementById('questionText');
        const optionsContainer = document.getElementById('optionsContainer');
        const currentPrizeElement = document.getElementById('currentPrize');
        const messageElement = document.getElementById('message');
        const nextQuestionButton = document.getElementById('nextQuestionButton');
        const lifeline5050Button = document.getElementById('lifeline5050');
        const lifelineSkipButton = document.getElementById('lifelineSkip');
        const lifelineAudienceButton = document.getElementById('lifelineAudience');
        const lifelineExpertButton = document.getElementById('lifelineExpert'); // New lifeline button
        const gameOverModal = document.getElementById('gameOverModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const nicknameInputContainer = document.getElementById('nicknameInputContainer');
        const nicknameInput = document.getElementById('nicknameInput');
        const saveScoreButton = document.getElementById('saveScoreButton');
        const modalRestartButton = document.getElementById('modalRestartButton');
        const modalHomeButton = document.getElementById('modalHomeButton');
        const timerDisplay = document.getElementById('timerDisplay');
        const timerProgressBar = document.getElementById('timerProgressBar');
        const timerText = document.getElementById('timerText');
        const questionCounter = document.getElementById('questionCounter');
        const highScoresModal = document.getElementById('highScoresModal');
        const loadingScores = document.getElementById('loadingScores');
        const highScoresList = document.getElementById('highScoresList');
        const closeScoresButton = document.getElementById('closeScoresButton');

        // Fun√ß√£o para embaralhar um array (algoritmo de Fisher-Yates)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; // Troca elementos
            }
            return array;
        }

        // Fun√ß√£o para simular atraso (para chamadas de API)
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Fun√ß√µes de inicializa√ß√£o de √°udio removidas

        // Inicializa o jogo e adiciona event listeners
        async function initGame() {
            if (startButton) startButton.addEventListener('click', async () => {
                startGame();
            });

            if (showScoresButton) showScoresButton.addEventListener('click', async () => {
                showHighScores();
            });

            difficultyButtons.forEach(button => {
                button.addEventListener('click', () => {
                    difficultyButtons.forEach(btn => btn.classList.remove('selected'));
                    button.classList.add('selected');
                    const selectedDifficulty = button.dataset.difficulty;
                    switch (selectedDifficulty) {
                        case 'easy': TIME_LIMIT = 45; break;
                        case 'medium': TIME_LIMIT = 30; break;
                        case 'hard': TIME_LIMIT = 15; break;
                    }
                    if (timerText) timerText.textContent = TIME_LIMIT;
                });
            });

            // Event listeners para toggle de m√∫sica e efeitos sonoros removidos

            if (lifeline5050Button) lifeline5050Button.addEventListener('click', () => {
                useLifeline5050();
            });
            if (lifelineSkipButton) lifelineSkipButton.addEventListener('click', () => {
                useLifelineSkip();
            });
            if (lifelineAudienceButton) lifelineAudienceButton.addEventListener('click', () => {
                useLifelineAudience();
            });
            if (lifelineExpertButton) lifelineExpertButton.addEventListener('click', async () => {
                await useLifelineExpert();
            });

            if (saveScoreButton) saveScoreButton.addEventListener('click', saveHighScore);
            if (modalRestartButton) modalRestartButton.addEventListener('click', () => {
                startGame();
            });
            if (modalHomeButton) modalHomeButton.addEventListener('click', () => {
                showWelcomeScreen();
            });
            if (closeScoresButton) closeScoresButton.addEventListener('click', () => {
                if (highScoresModal) highScoresModal.classList.add('hidden');
                showWelcomeScreen();
            });

            showWelcomeScreen();
        }

        // Fun√ß√µes de toggle de m√∫sica e efeitos sonoros removidas

        // Exibe a tela de boas-vindas
        async function showWelcomeScreen() {
            if (gameContainer) gameContainer.classList.add('hidden');
            if (gameOverModal) gameOverModal.classList.add('hidden');
            if (highScoresModal) highScoresModal.classList.add('hidden');
            if (welcomeScreen) welcomeScreen.classList.remove('hidden');

            // Parar m√∫sicas removido
        }

        // Inicia ou reinicia o jogo
        async function startGame() {
            gameStarted = true;
            currentQuestionIndex = 0;
            currentPrize = 0;
            lifeline5050Used = false;
            lifelineSkipUsed = false;
            lifelineAudienceUsed = false;
            lifelineExpertUsed = false; // Reset expert lifeline
            shuffledQuestions = shuffleArray([...questions]); // Cria uma c√≥pia e embaralha

            if (currentPrizeElement) currentPrizeElement.textContent = `R$ 0`;
            if (messageElement) messageElement.textContent = '';
            if (nextQuestionButton) nextQuestionButton.classList.add('hidden');
            if (welcomeScreen) welcomeScreen.classList.add('hidden');
            if (gameOverModal) gameOverModal.classList.add('hidden');
            if (highScoresModal) highScoresModal.classList.add('hidden');
            if (gameContainer) gameContainer.classList.remove('hidden');

            // Parar m√∫sicas removido

            // Habilita e reinicia as cores dos bot√µes de ajuda
            if (lifeline5050Button) { lifeline5050Button.disabled = false; lifeline5050Button.classList.remove('bg-gray-700'); }
            if (lifelineSkipButton) { lifelineSkipButton.disabled = false; lifelineSkipButton.classList.remove('bg-gray-700'); }
            if (lifelineAudienceButton) { lifelineAudienceButton.disabled = false; lifelineAudienceButton.classList.remove('bg-gray-700'); }
            if (lifelineExpertButton) { lifelineExpertButton.disabled = false; lifelineExpertButton.classList.remove('bg-gray-700'); }

            // Tocar som de in√≠cio de jogo removido
            // Iniciar m√∫sica de fundo removido

            displayQuestion();
        }

        // Exibe a pergunta atual
        async function displayQuestion() {
            canAnswer = true; // Permite que o usu√°rio responda
            const q = shuffledQuestions[currentQuestionIndex];
            if (questionText) questionText.textContent = q.question;
            if (optionsContainer) optionsContainer.innerHTML = ''; // Limpa as op√ß√µes anteriores

            if (questionCounter) questionCounter.textContent = `Pergunta ${currentQuestionIndex + 1} de ${shuffledQuestions.length}`;

            q.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.textContent = option;
                button.classList.add('option-button', 'block');
                button.dataset.index = index; // Armazena o √≠ndice da op√ß√£o
                button.addEventListener('click', () => checkAnswer(index));
                if (optionsContainer) optionsContainer.appendChild(button);
            });
            if (messageElement) messageElement.textContent = ''; // Limpa mensagens anteriores

            // Tocar m√∫sica de tens√£o removido

            startTimer(); // Inicia o temporizador para a nova pergunta
        }

        // Inicia o temporizador
        function startTimer() {
            clearInterval(timer); // Limpa qualquer timer anterior
            timeLeft = TIME_LIMIT;
            if (timerText) timerText.textContent = timeLeft;
            if (timerDisplay) timerDisplay.classList.remove('warning'); // Remove o estilo de aviso
            if (timerProgressBar) timerProgressBar.style.width = '100%'; // Reset progress bar

            timer = setInterval(() => {
                timeLeft--;
                if (timerText) timerText.textContent = timeLeft;
                const progress = (timeLeft / TIME_LIMIT) * 100;
                if (timerProgressBar) timerProgressBar.style.width = `${progress}%`;

                if (timeLeft <= 10 && timeLeft > 0) { // Adiciona aviso visual nos √∫ltimos 10 segundos
                    if (timerDisplay) timerDisplay.classList.add('warning');
                } else if (timeLeft <= 0) {
                    clearInterval(timer);
                    checkAnswer(-1); // Resposta incorreta se o tempo acabar
                }
            }, 1000);
        }

        // Para o temporizador
        function stopTimer() {
            clearInterval(timer);
            if (timerDisplay) timerDisplay.classList.remove('warning');
        }

        // Verifica a resposta selecionada
        async function checkAnswer(selectedIndex) {
            if (!canAnswer) return; // Impede m√∫ltiplos cliques
            stopTimer(); // Para o temporizador ao responder

            // Parar m√∫sica de tens√£o removido

            canAnswer = false; // Bloqueia novas respostas
            const q = shuffledQuestions[currentQuestionIndex];
            const allOptionButtons = optionsContainer ? optionsContainer.querySelectorAll('.option-button') : [];

            // Adiciona classes para feedback visual
            allOptionButtons.forEach((button, index) => {
                if (index === q.correctAnswerIndex) {
                    button.classList.add('correct');
                } else if (index === selectedIndex) {
                    button.classList.add('incorrect');
                }
                button.disabled = true; // Desabilita todos os bot√µes ap√≥s a resposta
            });

            // Exibe a explica√ß√£o
            if (messageElement) messageElement.innerHTML = `**${selectedIndex === q.correctAnswerIndex ? 'Correto! üéâ' : 'Incorreto. üòî'}**<br>${q.explanation}`;

            if (selectedIndex === q.correctAnswerIndex) {
                // Tocar som de correto removido
                currentPrize += q.prize;
                if (currentPrizeElement) currentPrizeElement.textContent = `R$ ${currentPrize.toLocaleString('pt-BR')}`;
                // Add pulse animation to prize
                if (currentPrizeElement) {
                    currentPrizeElement.classList.add('prize-pulse');
                    setTimeout(() => {
                        currentPrizeElement.classList.remove('prize-pulse');
                    }, 500); // Remove after animation
                }

                if (currentQuestionIndex < shuffledQuestions.length - 1) {
                    // Avan√ßa para a pr√≥xima pergunta ap√≥s um delay
                    setTimeout(() => {
                        loadNextQuestion();
                    }, EXPLANATION_DELAY);
                } else {
                    // Se for a √∫ltima pergunta e acertou, encerra o jogo com vit√≥ria
                    setTimeout(() => {
                        endGame(true);
                    }, EXPLANATION_DELAY);
                }
            } else {
                // Tocar som de incorreto removido
                setTimeout(() => {
                    endGame(false); // Perdeu o jogo ap√≥s o delay da explica√ß√£o
                }, EXPLANATION_DELAY);
            }
        }

        // Carrega a pr√≥xima pergunta
        function loadNextQuestion() {
            currentQuestionIndex++;
            if (nextQuestionButton) nextQuestionButton.classList.add('hidden'); // Garante que o bot√£o de pr√≥xima pergunta esteja escondido
            if (currentQuestionIndex < shuffledQuestions.length) {
                displayQuestion();
            } else {
                endGame(true); // Todas as perguntas respondidas
            }
        }

        // Usa a ajuda 50/50
        function useLifeline5050() {
            if (lifeline5050Used || !canAnswer) return;

            // Tocar som de ajuda removido
            lifeline5050Used = true;
            if (lifeline5050Button) {
                lifeline5050Button.disabled = true;
                lifeline5050Button.classList.add('bg-gray-700'); // Muda a cor para indicar uso
            }

            const q = shuffledQuestions[currentQuestionIndex];
            const allOptionButtons = optionsContainer ? optionsContainer.querySelectorAll('.option-button') : [];
            const incorrectOptions = [];

            allOptionButtons.forEach((button, index) => {
                if (index !== q.correctAnswerIndex) {
                    incorrectOptions.push(index);
                }
            });

            // Remove duas op√ß√µes incorretas aleatoriamente
            const optionsToRemove = shuffleArray(incorrectOptions).slice(0, 2);

            optionsToRemove.forEach(index => {
                if (allOptionButtons[index]) {
                    allOptionButtons[index].style.opacity = '0.3'; // Diminui a opacidade
                    allOptionButtons[index].disabled = true; // Desabilita
                }
            });

            if (messageElement) messageElement.textContent = 'Ajuda 50/50 utilizada! Duas op√ß√µes incorretas foram removidas.';
        }

        // Usa a ajuda Pular Pergunta
        function useLifelineSkip() {
            if (lifelineSkipUsed || !canAnswer) return;

            // Tocar som de ajuda removido
            lifelineSkipUsed = true;
            if (lifelineSkipButton) {
                lifelineSkipButton.disabled = true;
                lifelineSkipButton.classList.add('bg-gray-700'); // Muda a cor para indicar uso
            }

            const skipCost = Math.floor(currentPrize * 0.10); // 10% of current prize
            currentPrize = Math.max(0, currentPrize - skipCost); // Ensure prize doesn't go negative

            if (messageElement) messageElement.textContent = `Ajuda Pular Pergunta utilizada! R$ ${skipCost.toLocaleString('pt-BR')} deduzidos. Pulando para a pr√≥xima quest√£o.`;
            if (currentPrizeElement) currentPrizeElement.textContent = `R$ ${currentPrize.toLocaleString('pt-BR')}`; // Update prize display with deduction
            // Add pulse animation to prize after deduction
            if (currentPrizeElement) {
                currentPrizeElement.classList.add('prize-pulse');
                setTimeout(() => {
                    currentPrizeElement.classList.remove('prize-pulse');
                }, 500); // Remove after animation
            }

            stopTimer(); // Para o timer ao pular
            setTimeout(() => {
                loadNextQuestion();
            }, 1500); // D√° um pequeno delay para a mensagem ser lida
        }

        // Usa a ajuda "Perguntar aos Universit√°rios"
        function useLifelineAudience() {
            if (lifelineAudienceUsed || !canAnswer) return;

            // Tocar som de ajuda removido
            lifelineAudienceUsed = true;
            if (lifelineAudienceButton) {
                lifelineAudienceButton.disabled = true;
                lifelineAudienceButton.classList.add('bg-gray-700'); // Muda a cor para indicar uso
            }

            const q = shuffledQuestions[currentQuestionIndex];
            const allOptionButtons = optionsContainer ? optionsContainer.querySelectorAll('.option-button') : [];

            // Simulate audience votes
            const votes = Array(q.options.length).fill(0);
            const correctIndex = q.correctAnswerIndex;

            // Give correct answer a high percentage (e.g., 60-80%)
            let remainingPercentage = 100;
            const correctVote = Math.floor(Math.random() * 21) + 60; // 60-80%
            votes[correctIndex] = correctVote;
            remainingPercentage -= correctVote;

            // Distribute remaining percentage among incorrect answers
            const incorrectIndices = Array.from({ length: q.options.length }, (_, i) => i)
                                        .filter(i => i !== correctIndex);

            // Distribute remaining votes, ensuring at least 1% for each remaining option
            let distributedVotes = 0;
            incorrectIndices.forEach(idx => {
                const minVote = 1; // Minimum 1%
                let vote = Math.floor(Math.random() * (remainingPercentage - (incorrectIndices.length - 1 - distributedVotes) * minVote));
                if (vote < minVote) vote = minVote; // Ensure minimum
                votes[idx] = vote;
                remainingPercentage -= vote;
                distributedVotes++;
            });

            // If there's any remaining percentage due to rounding, add it to one of the incorrect options
            if (remainingPercentage > 0 && incorrectIndices.length > 0) {
                votes[incorrectIndices[0]] += remainingPercentage;
            }

            // Ensure total sums to 100 (adjust if needed due to rounding)
            const totalVotes = votes.reduce((sum, v) => sum + v, 0);
            if (totalVotes !== 100) {
                votes[correctIndex] += (100 - totalVotes);
            }

            allOptionButtons.forEach((button, index) => {
                if (button) { // Ensure button exists before appending
                    const percentage = votes[index];
                    const span = document.createElement('span');
                    span.classList.add('ml-4', 'font-bold');
                    span.textContent = `${percentage}%`;
                    button.appendChild(span);
                }
            });

            if (messageElement) messageElement.textContent = 'Os universit√°rios votaram! Veja os resultados.';
        }

        // Nova fun√ß√£o: Usar ajuda "Perguntar ao Especialista" (LLM-powered)
        async function useLifelineExpert() {
            if (lifelineExpertUsed || !canAnswer) return;

            // Tocar som de ajuda removido
            lifelineExpertUsed = true;
            if (lifelineExpertButton) {
                lifelineExpertButton.disabled = true;
                lifelineExpertButton.classList.add('bg-gray-700');
            }

            if (messageElement) {
                messageElement.innerHTML = 'Consultando o especialista... <span class="loading-spinner"></span>';
            }
            stopTimer(); // Stop timer while LLM is thinking

            const q = shuffledQuestions[currentQuestionIndex];
            const prompt = `Dada a seguinte pergunta de embriologia e as op√ß√µes de resposta, atue como um especialista e forne√ßa a resposta mais prov√°vel e uma breve explica√ß√£o. A sua resposta deve ser formatada como um objeto JSON com as chaves 'suggestedAnswer' (a letra da op√ß√£o, ex: 'A', 'B', 'C', 'D') e 'explanation' (uma breve justifica√ß√£o).
            Pergunta: '${q.question}'
            Op√ß√µes: ${q.options.join(', ')}`;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });

            const payload = {
                contents: chatHistory,
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "suggestedAnswer": { "type": "STRING" },
                            "explanation": { "type": "STRING" }
                        },
                        "required": ["suggestedAnswer", "explanation"]
                    }
                }
            };

            const apiKey = typeof __gemini_api_key !== 'undefined' ? __gemini_api_key : ""; // Canvas will provide this at runtime
            if (!apiKey) {
                console.error("Gemini API key is not provided by the environment.");
                if (messageElement) messageElement.textContent = 'Erro: Chave da API Gemini n√£o dispon√≠vel. Esta ajuda n√£o pode ser usada.';
                startTimer(); // Restart timer
                return;
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            let expertResponse = null;
            let retries = 0;
            const MAX_RETRIES = 3;
            const BASE_DELAY = 1000; // 1 second

            while (retries < MAX_RETRIES) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const json = result.candidates[0].content.parts[0].text;
                        expertResponse = JSON.parse(json);
                        break; // Success, exit loop
                    } else {
                        throw new Error("Unexpected API response structure.");
                    }
                } catch (error) {
                    console.error(`Error calling Gemini API (attempt ${retries + 1}):`, error);
                    retries++;
                    if (retries < MAX_RETRIES) {
                        const delay = BASE_DELAY * Math.pow(2, retries); // Exponential backoff
                        await sleep(delay);
                    }
                }
            }

            if (expertResponse) {
                let expertAnswerText = expertResponse.suggestedAnswer;
                let expertExplanation = expertResponse.explanation;

                // Simulate a small chance of the expert being wrong (e.g., 10% chance)
                const isExpertWrong = Math.random() < 0.10; // 10% chance of being wrong

                if (isExpertWrong) {
                    // If the expert is supposed to be wrong, pick a random incorrect option
                    const incorrectOptions = q.options.filter((_, idx) => idx !== q.correctAnswerIndex);
                    const randomIncorrectOption = incorrectOptions[Math.floor(Math.random() * incorrectOptions.length)];
                    expertAnswerText = randomIncorrectOption.charAt(0); // Get the letter (A, B, C, D)
                    expertExplanation = "A minha an√°lise sugere esta resposta, mas a embriologia pode ser trai√ßoeira! Verifique com cuidado."; // Generic wrong explanation
                }

                if (messageElement) {
                    messageElement.innerHTML = `**O Especialista Sugere:** ${expertAnswerText}<br>_Explica√ß√£o:_ ${expertExplanation}`;
                }
            } else {
                if (messageElement) {
                    messageElement.textContent = 'O especialista est√° ocupado... Tente novamente mais tarde ou confie nos seus conhecimentos!';
                }
            }
            startTimer(); // Restart timer after LLM response
        }

        // Finaliza o jogo
        function endGame(won) {
            gameStarted = false;
            stopTimer(); // Garante que o timer pare
            if (gameContainer) gameContainer.classList.add('hidden'); // Esconde o container do jogo
            // Parar m√∫sicas removido

            if (won) {
                // Tocar som de vit√≥ria removido
                if (modalTitle) modalTitle.textContent = 'Parab√©ns! üèÜ';
                if (modalMessage) modalMessage.textContent = `Voc√™ ganhou o Show do Milh√£o de Embriologia com R$ ${currentPrize.toLocaleString('pt-BR')}!`;
                triggerConfetti(); // Chama a fun√ß√£o de confetes
            } else {
                // Tocar som de derrota removido
                if (modalTitle) modalTitle.textContent = 'Fim de Jogo üòî';
                if (modalMessage) modalMessage.textContent = `Voc√™ acumulou R$ ${currentPrize.toLocaleString('pt-BR')}. Tente novamente!`;
            }

            // Show nickname input if score is positive
            if (currentPrize > 0) {
                if (nicknameInputContainer) nicknameInputContainer.classList.remove('hidden');
                if (nicknameInput) nicknameInput.value = ''; // Clear previous nickname
            } else {
                if (nicknameInputContainer) nicknameInputContainer.classList.add('hidden');
            }

            if (gameOverModal) gameOverModal.classList.remove('hidden'); // Mostra o modal de fim de jogo
        }

        // Fun√ß√£o para salvar a pontua√ß√£o no Firestore
        async function saveHighScore() {
            if (!window.firebaseInitialized || !window.db) { // Use window.db
                console.error("Firebase: N√£o inicializado. N√£o √© poss√≠vel salvar a pontua√ß√£o.");
                if (messageElement) messageElement.textContent = "Erro: Firebase n√£o dispon√≠vel para salvar pontua√ß√£o. Verifique a consola para detalhes.";
                return;
            }

            const nickname = nicknameInput ? nicknameInput.value.trim() : '';
            if (nickname.length < 2) {
                if (messageElement) messageElement.textContent = "Por favor, insira um nickname com pelo menos 2 caracteres.";
                return;
            }

            if (saveScoreButton) saveScoreButton.disabled = true;
            if (nicknameInput) nicknameInput.disabled = true;
            if (messageElement) messageElement.textContent = "Salvando pontua√ß√£o...";

            try {
                const highScoresCollectionRef = window.collection(window.db, `artifacts/${window.appId}/public/data/highScores`); // Use window.collection, window.db, window.appId
                await window.addDoc(highScoresCollectionRef, { // Use window.addDoc
                    nickname: nickname,
                    score: currentPrize,
                    timestamp: Date.now(),
                    userId: window.getUserId() // Use window.getUserId
                });
                if (messageElement) messageElement.textContent = "Pontua√ß√£o salva com sucesso! üéâ";
                if (nicknameInputContainer) nicknameInputContainer.classList.add('hidden'); // Hide input after saving
            } catch (error) {
                console.error("Erro ao salvar pontua√ß√£o:", error);
                if (messageElement) messageElement.textContent = "Erro ao salvar pontua√ß√£o. Tente novamente.";
            } finally {
                if (saveScoreButton) saveScoreButton.disabled = false;
                if (nicknameInput) nicknameInput.disabled = false;
            }
        }

        // Fun√ß√£o para exibir o placar de pontos
        async function showHighScores() {
            if (welcomeScreen) welcomeScreen.classList.add('hidden');
            if (gameContainer) gameContainer.classList.add('hidden');
            if (gameOverModal) gameOverModal.classList.add('hidden');
            if (highScoresModal) highScoresModal.classList.remove('hidden');
            if (loadingScores) loadingScores.classList.remove('hidden');
            if (highScoresList) highScoresList.innerHTML = ''; // Clear previous scores

            // Parar m√∫sicas removido

            if (!window.firebaseInitialized || !window.db) { // Use window.db
                if (loadingScores) loadingScores.textContent = "Erro: Firebase n√£o dispon√≠vel para carregar placar.";
                return;
            }

            try {
                const highScoresCollectionRef = window.collection(window.db, `artifacts/${window.appId}/public/data/highScores`); // Use window.collection, window.db, window.appId
                // Removido window.orderBy("score", "desc") para evitar problemas de √≠ndice
                const q = window.query(highScoresCollectionRef, window.limit(10)); // Use window.query, window.limit

                window.onSnapshot(q, (snapshot) => { // Use window.onSnapshot
                    if (loadingScores) loadingScores.classList.add('hidden');
                    if (highScoresList) highScoresList.innerHTML = ''; // Clear for real-time updates
                    if (snapshot.empty) {
                        if (highScoresList) highScoresList.innerHTML = '<li class="text-gray-400">Nenhuma pontua√ß√£o ainda. Seja o primeiro!</li>';
                    } else {
                        // Coleta os dados e ordena em JavaScript
                        const scores = [];
                        snapshot.forEach((doc) => {
                            scores.push(doc.data());
                        });

                        // Ordena as pontua√ß√µes em ordem decrescente (do maior para o menor)
                        scores.sort((a, b) => b.score - a.score);

                        scores.forEach((scoreData) => {
                            const listItem = document.createElement('li');
                            listItem.innerHTML = `
                                <span>${scoreData.nickname}</span>
                                <span>R$ ${scoreData.score.toLocaleString('pt-BR')}</span>
                            `;
                            if (highScoresList) highScoresList.appendChild(listItem);
                        });
                    }
                }, (error) => {
                    console.error("Error fetching real-time high scores:", error);
                    if (loadingScores) loadingScores.textContent = "Erro ao carregar placar. Tente novamente.";
                });

            } catch (error) {
                console.error("Error setting up high scores listener:", error);
                if (loadingScores) loadingScores.textContent = "Erro ao carregar placar. Tente novamente.";
            }
        }

        // Fun√ß√£o para disparar confetes
        function triggerConfetti() {
            const colors = ['#f0f', '#0ff', '#ff0', '#f00', '#0f0', '#00f'];
            const numConfetti = 100;

            for (let i = 0; i < numConfetti; i++) {
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                confetti.style.left = `${Math.random() * 100}vw`;
                confetti.style.animationDelay = `${Math.random() * 2}s`;
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.transform = `translateY(-100px) rotateZ(${Math.random() * 360}deg)`;
                document.body.appendChild(confetti);

                // Remove o confete ap√≥s a anima√ß√£o para limpar o DOM
                confetti.addEventListener('animationend', () => {
                    confetti.remove();
                });
            }
        }

        // Inicia o jogo quando o Firebase estiver pronto
        window.onFirebaseReady = initGame;
        // If Firebase is already initialized (e.g., on subsequent runs in the same session), call initGame directly
        if (window.firebaseInitialized) {
            initGame();
        }
    </script>
</body>
</html>
